show user;

/* EXIBE O USUÁRIO */
SELECT * FROM DICT;

-- TABLE DUMMY / TABLE IDIOTA
SELECT 1 + 1;

SELECT 1 + 1 FROM DUAL;

SELECT 1 + 1 SOMA FROM DUAL;

SELECT 1 + 1 AS SOMA FROM DUAL; -- FAÇAM DESSA FORMA

SELECT 1 + 1  "SOMA" FROM DUAL;

-- VERIFICANDO O AMBIENTE
-- B023 = 32 bits
-- B047 = 64 bits
SELECT METADATA FROM SYS.KOPM$;

-- DICIONARIO DE DADOS
SELECT * FROM DICT
ORDER BY 1;

-- INSTANCIA
-- UNICA OU RAC?
-- EU ESTOU USANDO PARALELISMO?
SELECT PARALLEL FROM v$instance;

-- ESTRUTURA DE MEMORIA
SELECT COMPONENT, CURRENT_SIZE, MIN_SIZE, MAX_SIZE
FROM V$SGA_DYNAMIC_COMPONENTS;

-- OUTRAS BANCOS
SQLPLUS SYSTEM/SENHA@NOMEDOBANCO2
ORACLE_SID=XE

-- NOME DO BANCO DE DADOS
SELECT NAME FROM V$DATABASE;

-- VERSÃO DO BANCO DE DADOS
SELECT BANNER FROM V$VERSION;

-- VERIFICAR PREVILEGIOS DO USUARIO
SELECT * FROM USER_SYS_PRIVS;

-- TABELAS DO USUARIO
SELECT TABLE_NAME FROM USER_TABLES;

SELECT COUNT(TABLE_NAME) FROM USER_TABLES;

/* ARMAZENAMENTOS
LÓGICO - TABLESPACES - SEGMENTOS (OBJETOS) - 
EXTENSÕES (ESPAÇOS) - BLOCOS (DOS SISTEMA OPERACIONAL)

FISICO - DATAFILES
*/

/* NÃO PODEMOS DETERMINAR EM QUAL ARQUIVO FISICO UM OBJETO FICARÁ. */

CREATE TABLE cursos(
    IDCURSO INT PRIMARY KEY,
    NOME VARCHAR2(30),
    CARGA INT
) TABLESPACE USERS;

CREATE TABLE TESTE(
    IDTESTE INT PRIMARY KEY,
    NOME VARCHAR2(30)
);

SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES;

SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES
WHERE TABLE_NAME = 'CURSOS';

SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES
WHERE TABLE_NAME = 'TESTE';

/* TODO OBJETO É CRIADO POR PADRÃO NA TABLESPACE
USERS, EXCETO QUANDO SE ESTA LOGADO COM O USUARIO
SYSTEM - ENTAO O OBJETO SERA CRIADO NA TABLESPACE
SYSTEM */

SELECT SEGMENT_NAME, SEGMENT_TYPE, TABLESPACE_NAME,
BYTES, BLOCKS, EXTENTS FROM USER_SEGMENTS;

SELECT SEGMENT_NAME, SEGMENT_TYPE, TABLESPACE_NAME,
BYTES, BLOCKS, EXTENTS FROM USER_SEGMENTS
WHERE SEGMENT_NAME = 'CURSOS';

/* FORMATANDO COLUNAS - PARA O TERMINAL */

COLUMN SEGMENT_NAME FORMAT A20;
COLUMN TABLESPACE_NAME FORMAT A20;
COLUMN SEGMENT_TYPE FORMAT A20;

-- CRIANDO TABLESPACE
CREATE TABLESPACE RECURSOS_HUMANOS
DATAFILE '/u01/app/oracle/oradata/XE/RH_01.DBF'
SIZE 100M AUTOEXTEND
ON NEXT 100M
MAXSIZE 4096M;

/* ALTERANDO TABLESPACE */
ALTER TABLESPACE RECURSOS_HUMANOS
ADD DATAFILE '/u01/app/oracle/oradata/XE/RH_02.DBF'
SIZE 200M AUTOEXTEND
ON NEXT 200M
MAXSIZE 4096M;

SELECT TABLESPACE_NAME, FILE_NAME FROM DBA_DATA_FILES;

-- SEQUENCES

CREATE SEQUENCE SEQ_GERAL
START WITH 100
INCREMENT BY 10;

-- CRIANDO UMA TABELA NA TABLESPACE

CREATE TABLE FUNCIONARIOS(
    IDFUNCIONARIO INT PRIMARY KEY,
    NOME VARCHAR2(30)
) TABLESPACE RECURSOS_HUMANOS;

INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL, 'JOÃO');
INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL, 'CLARA');
INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL, 'LILIAM');

SELECT * FROM FUNCIONARIOS;

COMMIT;

-- CRIANDO TABLESPACE DE MARKETING
CREATE TABLESPACE MARKETING
DATAFILE '/u01/app/oracle/oradata/XE/MKT_01.DBF'
SIZE 100M AUTOEXTEND
ON NEXT 100M
MAXSIZE 4096M;

CREATE TABLE CAMPANHAS(
    IDCAMPANHA INT PRIMARY KEY,
    NOME VARCHAR2(30)
) TABLESPACE MARKETING;

INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL, 'PRIMAVERA');
INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL, 'VERÃO');
INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL, 'INVERNO');

SELECT * FROM FUNCIONARIOS;
SELECT * FROM CAMPANHAS;

-- COLOCANDO A TABLESPACE OFFLINE

ALTER TABLESPACE RECURSOS_HUMANOS OFFLINE;

-- APONTAR DICIONARIO DE DADOS

ALTER TABLESPACE RECURSOS_HUMANOS
RENAME DATAFILE '/u01/app/oracle/oradata/PRODUCAO/RH_01.DBF' TO '/u01/app/oracle/oradata/XE/PRODUCAO/RH_01.DBF';

ALTER TABLESPACE RECURSOS_HUMANOS
RENAME DATAFILE '/u01/app/oracle/oradata/PRODUCAO/RH_02.DBF' TO '/u01/app/oracle/oradata/XE/PRODUCAO/RH_02.DBF';

-- COLOCANDO A TABLESPACE ONLINE

ALTER TABLESPACE RECURSOS_HUMANOS ONLINE;

SELECT * FROM FUNCIONARIOS;
SELECT * FROM CAMPANHAS;

CREATE TABLE ALUNOS(
    IDALUNO INT PRIMARY KEY,
    NOME VARCHAR2(30),
    EMAIL VARCHAR2(30),
    SALARIO NUMBER(10,2)
);

CREATE SEQUENCE SEQ_EXEMPLO;

INSERT INTO ALUNOS VALUES (SEQ_EXEMPLO.NEXTVAL, 'JOAO', 'JOAO@GMAIL.COM', 1000.00);
INSERT INTO ALUNOS VALUES (SEQ_EXEMPLO.NEXTVAL, 'CLARA', 'CLARA@GMAIL.COM', 2000.00);
INSERT INTO ALUNOS VALUES (SEQ_EXEMPLO.NEXTVAL, 'CELIA', 'CELIA@GMAIL.COM', 2000.00);

SELECT * FROM ALUNOS;

CREATE TABLE ALUNOS2(
    IDALUNO INT PRIMARY KEY,
    NOME VARCHAR2(30),
    EMAIL VARCHAR2(30),
    SALARIO NUMBER(10,2)
);

INSERT INTO ALUNOS2 VALUES (SEQ_EXEMPLO.NEXTVAL, 'JOAO', 'JOAO@GMAIL.COM', 1000.00);
INSERT INTO ALUNOS2 VALUES (SEQ_EXEMPLO.NEXTVAL, 'CLARA', 'CLARA@GMAIL.COM', 2000.00);
INSERT INTO ALUNOS2 VALUES (SEQ_EXEMPLO.NEXTVAL, 'CELIA', 'CELIA@GMAIL.COM', 2000.00);

SELECT * FROM ALUNOS;
SELECT * FROM ALUNOS2;

/* ROWID E ROWNUM */

SELECT ROWID, IDALUNO, NOME, EMAIL FROM ALUNOS;

SELECT ROWNUM, IDALUNO, NOME, EMAIL FROM ALUNOS2;

SELECT NOME, EMAIL FROM ALUNOS
WHERE ROWNUM <= 2;

COMMIT;

/* PROCEDURE */
CREATE OR REPLACE PROCEDURE BONUS(P_IDALUNO ALUNOS.IDALUNO%TYPE, P_PERCENT NUMBER)
AS
    BEGIN
            UPDATE ALUNOS SET SALARIO = SALARIO + (SALARIO * (P_PERCENT /100))
            WHERE ALUNOS.IDALUNO = P_IDALUNO;   
    END;
    /

SELECT * FROM ALUNOS;

-- CHAMANDO UMA PROCEDURE
CALL BONUS(3, 10);

/* AS TRIGGERS DEVEM TER TAMANHO MAXIMO DE 32K
NÃO EXECUTAM COMANDO DE DTL - COMMIT, ROLLBACK E SAVEPOINTS */

/* VALIDAÇÃO */

CREATE OR REPLACE TRIGGER CHECK_SALARIO
BEFORE INSERT OR UPDATE ON ALUNOS
FOR EACH ROW
BEGIN

    IF :NEW.SALARIO < 2000 THEN
        RAISE_APPLICATION_ERROR(-20000, 'VAL0R INCORRETO');
    END IF;

END;
/

/* EXIBE OS ERROS */
SHOW ERRORS;

INSERT INTO ALUNOS VALUES (SEQ_EXEMPLO.NEXTVAL, 'DANIEL', 'DANIEL@GMAIL.COM', 100.00);

/* VERIFICAR TRIGGERS */

SELECT TRIGGER_NAME, TRIGGER_BODY
FROM USER_TRIGGERS;

/* TRIGGER DE EVENTOS */

CREATE TABLE AUDITORIA(
    DATE_LOGIN DATE,
    LOGIN VARCHAR2(30)
);

CREATE OR REPLACE PROCEDURE LOG_PROC IS
BEGIN
    INSERT INTO AUDITORIA(DATE_LOGIN, LOGIN) VALUES (SYSDATE, USER);
END LOG_PROC;
/

SELECT SYSDATE, USER FROM DUAL;

CREATE OR REPLACE TRIGGER LOGTRIGGER
AFTER LOGON ON DATABASE
CALL LOG_PROC
/

SELECT * FROM AUDITORIA;

-- FALHA DE LOGON

CREATE OR REPLACE TRIGGER FALHA_LOGON
AFTER SERVERERROR
ON DATABASE
BEGIN
    IF (IS_SERVERERROR(1017)) THEN
        INSERT INTO AUDITORIA(DATE_LOGIN, LOGIN) VALUES (SYSDATE, 'ORA-1017');
    END IF;

END FALHA_LOGON;
/

SELECT * FROM AUDITORIA;

/* ERROS ORACLE */

-- 1004 - DEFAULT USERNAME FEATURE NOT SUPPORTED (ERRO DO USUÁRIO)
-- 1005 - PASSWORD NULO
-- 1045 - PRIVILEGIO INSUFICIENTE

CREATE TABLE USUARIO(
    ID INT,
    NOME VARCHAR(30)
);

CREATE TABLE BKP_USUARIO(
    ID INT,
    NOME VARCHAR(30)
);

INSERT INTO USUARIO VALUES (1, 'JOÃO');
INSERT INTO USUARIO VALUES (2, 'CLARA');

COMMIT;

SELECT * FROM USUARIO;

CREATE OR REPLACE TRIGGER LOG_USUARIO
BEFORE DELETE ON USUARIO
FOR EACH ROW

BEGIN
    INSERT INTO BKP_USUARIO VALUES
    (:OLD.ID, :OLD.NOME);
END;
/

SELECT * FROM BKP_USUARIO;

SELECT * FROM USUARIO;

DELETE FROM USUARIO WHERE ID = 1;

-- OPERAÇÕES COM VIEWS

CREATE TABLE CLIENTE(
    IDCLIENTE INT PRIMARY KEY,
    NOME VARCHAR(30),
    SEXO CHAR(1)
);

INSERT INTO CLIENTE VALUES (1007, 'MAFRA', 'M');
COMMIT;

SELECT * FROM CLIENTE;

CREATE OR REPLACE VIEW V_CLIENTE
AS
    SELECT IDCLIENTE, NOME, SEXO
    FROM CLIENTE;

-- CHAMANDO A VIEW
SELECT * FROM V_CLIENTE;

/* INSERT NA VIEW, PORÉM QUANDO HÁ SOMENTE UMA TABLE
SE DUAS OU MAIS, TEM QUE TER PROGRAMAÇÃO */
INSERT INTO V_CLIENTE VALUES (1008, 'DANIEL', 'M');

-- VIEW SOMENTE PARA LEITURA
CREATE OR REPLACE VIEW V_CLIENTE_RO
AS
    SELECT IDCLIENTE, NOME, SEXO
    FROM CLIENTE
    WITH READ ONLY;

INSERT INTO V_CLIENTE_RO VALUES (1009, 'CLARA', 'F');

-- VIEW DE JOIN
CREATE OR REPLACE VIEW V_RELATORIO
AS
    SELECT NOME, SEXO, NUMERO
    FROM CLIENTE
    INNER JOIN TELEFONE
    ON IDCLIENTE = ID_CLIENTE;

-- FORCE PARA FORÇAR CRIAR A VIEW

CREATE OR REPLACE FORCE VIEW V_RELATORIO
AS
    SELECT NOME, SEXO, NUMERO
    FROM CLIENTE
    INNER JOIN TELEFONE
    ON IDCLIENTE = ID_CLIENTE;
    
SELECT * FROM V_RELATORIO;

CREATE TABLE TELEFONE(
    IDTELEFONE INT PRIMARY KEY,
    NUMERO VARCHAR2(10),
    ID_CLIENTE INT
);

ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE);

INSERT INTO TELEFONE VALUES (1, '34543355', 1007);

COMMIT;

/* DEFERRABLE CONSTRAINTS */

CREATE TABLE FUNCIONARIO(
    IDFUNCIONARIO INT CONSTRAINT PK_FUNCIONARIO PRIMARY KEY,
    NOME VARCHAR2(100)
);

DROP TABLE TELEFONE;

CREATE TABLE TELEFONE(
    IDTELEFONE INT PRIMARY KEY,
    NUMERO VARCHAR2(10),
    ID_FUNCIONARIO INT
);

ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE
FOREIGN KEY (ID_FUNCIONARIO) REFERENCES FUNCIONARIO(IDFUNCIONARIO);

INSERT INTO FUNCIONARIO VALUES (1, 'MAURICIO');

INSERT INTO TELEFONE VALUES (10, '25659875', 1);

/* A CONSTRAINT DE INTEGRIDADE REFERENCIAL (FK)
CHECA A INTEGRIDADE LOGO APOS O COMANDO DE DML
INSERT | DELETE | UPDATE - NÃO POSSIBILITANDO ASSIM
A INSERÇÃO DE REGISTROS SEM REFERENCIA */

INSERT INTO TELEFONE VALUES (12, '89564796', 34);

DELETE FUNCIONARIO WHERE IDFUNCIONARIO = 1;

SELECT * FROM FUNCIONARIO;

SELECT * FROM TELEFONE;

-- VERIFICANDO STATUS DA CONSTRAINTS 

SELECT CONSTRAINT_NAME, DEFERRABLE, DEFERRED
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('FUNCIONARIO', 'TELEFONE');

/* APAGANDO AS CONSTRAINTS */

ALTER TABLE TELEFONE
DROP CONSTRAINT FK_TELEFONE;

-- RECRIANDO A CONSTRAINT
ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE 
FOREIGN KEY(ID_FUNCIONARIO) REFERENCES FUNCIONARIO
DEFERRABLE;

SELECT CONSTRAINT_NAME, DEFERRABLE AS ATRASADA, DEFERRED AS VERIFICACAO
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('FUNCIONARIO', 'TELEFONE');

SELECT * FROM FUNCIONARIO;

INSERT INTO TELEFONE VALUES (12, '89564796', 34);

-- MUDANDO A VERICACAO PARA DTL

SET CONSTRAINTS ALL DEFERRED;

SELECT * FROM TELEFONE;

COMMIT;